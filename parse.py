#!/usr/bin/env python3

import re
import sys

from collections import Counter
from pathlib import Path
from pprint import pprint
from itertools import islice

import arrow

from arrow.parser import ParserError

from tqdm import tqdm

RE_DATE_STRING = re.compile(r'# This data file generated by 23andMe at: (.*)')

VERSION_DATES = {
    '2006-01-01': ['v1'],
    '2008-09-01': ['v1', 'v2'],
    '2011-01-01': ['v1', 'v2', 'v3'],
    '2013-01-01': ['v1', 'v2', 'v3', 'v4'],
    '2017-08-01': ['v1', 'v2', 'v3', 'v4', 'v5'],
}

ALL_VERSIONS = ['v1', 'v2', 'v3', 'v4', 'v5']

V1_ONLY = [
    'rs2176348',
    'rs1067',
    'rs215643',
    'rs228798',
    'rs511055',
    'rs652754',
    'rs758891',
    'rs950758',
    'rs991638',
    'rs1146119',
    'rs1148592',
    'rs1254597',
    'rs1446481',
    'rs1531309',
    'rs1733875',
]

V2_ONLY = [
]

V3_ONLY = [
    'rs2862633',
    'rs10867964',
    'rs12914236',
    'rs51',
    'rs60',
    'rs117',
    'rs144',
    'rs146',
    'rs173',
    'rs195',
    'rs198',
    'rs213',
    'rs227',
    'rs239',
    'rs346',
]

V4_ONLY = [
    'rs1800123',
    'rs1801267',
    'rs1805009',
    'rs3819055',
    'rs7769409',
    'rs12721655',
    'rs28357985',
    'rs28942112',
    'rs56379106',
    'rs72558189',
    'rs74315300',
    'rs74315329',
    'rs74315403',
    'rs80358217',
    'rs104893783',
]

V5_ONLY = [
    'rs80359670',
    'rs80357600',
    'rs80358382',
    'rs80359763',
    'rs113994200',
    'rs201057210',
    'rs267608497',
    'rs386134261',
    'rs397508103',
    'rs397516667',
    'rs398123599',
    'rs587779247',
    'rs587779352',
    'rs587781516',
    'rs587781849',
]

# snp_dates = {}

# with Path('./snp-dates.csv').open() as file:
#     for line in file:
#         snp, date = line.split(',')
#         snp_dates[snp.lower().strip()] = date.strip()


def snp_version(snp):
    if snp in V1_ONLY:
        return 'v1'

    if snp in V2_ONLY:
        return 'v2'

    if snp in V3_ONLY:
        return 'v3'

    if snp in V4_ONLY:
        return 'v4'

    if snp in V5_ONLY:
        return 'v5'


def convert(text):
    return int(text) if text.isdigit() else text


def alphanum_key(text):
    return [convert(c) for c in re.split('([0-9]+)', text)]


def head(path, lines=25):
    with path.open() as file:
        return list(islice(file, lines))


def classify(path):
    chromosomes =  Counter()
    versions = Counter()

    snps = []

    lines = 0
    i_snps = 0

    with path.open() as file:
        for line in file:
            if line[0] == '#':
                continue

            try:
                snp, chromosome, _, _ = line.split('\t')
            except ValueError:
                continue

                # some generated files have a weird format...
                # try:
                #     snp, chromosome, _, _, _ = line.split('\t')
                # except ValueError:
                #     from IPython import embed; embed()

            if not snp or not chromosome:
                continue

            chromosomes[chromosome] += 1

            if snp[0] == 'i':
                i_snps += 1
            else:
                snps.append(snp)

            version = snp_version(snp)

            if version:
                versions[version] += 1

            lines += 1

    return (
        versions,
        lines,
        i_snps,
        snps,
        chromosomes,
    )


def get_version(lines, date, i_snps):
    if date:
        for start_date, versions in VERSION_DATES.items():
            if date > arrow.get(start_date):
                potential_versions = versions
    else:
        potential_versions = ALL_VERSIONS

    version = ''

    if not i_snps:
        return '-'

    if lines >= 900000:
        version = 'v3'
    elif lines >= 633416:
        version = 'v5'
    elif lines >= 598897:
        version = 'v4'
    elif lines >= 576028:
        version = 'v1'
    elif lines >= 572000:
        version = 'v2'

    if version and version not in potential_versions:
        version = f'{version}*'

    return version


def main():
    cwd = Path('.')

    all_counts = Counter()

    version_counts = {
        'v1': Counter(),
        'v2': Counter(),
        'v3': Counter(),
        'v4': Counter(),
        'v5': Counter(),
    }

    versions = Counter()
    total = 0

    chromosome_header = ','.join(str(x) for x in range(1, 23))

    print(f'Version,Generated,Total i,Lines,V1,V2,V3,V4,V5,{chromosome_header},X,Y,MT,Name')

    files = list(cwd.glob('*-genotyping.txt')) + list(cwd.glob('opensnp/*.23andme.*'))

    for path in tqdm(files, unit='file'):
        try:
            (
                versions,
                lines,
                i_snps,
                snps,
                chromosomes,
             ) = classify(path)
        except UnicodeDecodeError as e:
            print(f'Unable to read "{path.name}": {e}', file=sys.stderr)
            continue

        if lines < 400000:
            continue

        first_lines = head(path)

        for line in first_lines:
            match = RE_DATE_STRING.match(line)

            if match:
                break

        if match:
            # 'Wed May 24 08:09:20 2017'
            date_string = re.sub(r'\s+', ' ', match.group(1))

            try:
                date = arrow.get(date_string, 'ddd MMM D HH:mm:ss YYYY')
            except ParserError as e:
                print(f'Unable to parse "{date_string}" in "{path.name}": {e}')
                date = None
        else:
            date = None

        version = get_version(lines, date, i_snps)

        if version in version_counts:
            versions[version] += 1
            total += 1

            version_counts[version].update(snps)
            all_counts.update(snps)

        versions_string = f'{versions["v1"]},'
        versions_string += f'{versions["v2"]},'
        versions_string += f'{versions["v3"]},'
        versions_string += f'{versions["v4"]},'
        versions_string += f'{versions["v5"]}'

        chromosome_total = sum(count for count in chromosomes.values())

        chromosome_string = ''

        for i in range(1, 23):
            chromosome_string += f'{round(chromosomes[str(i)] / chromosome_total, 4)},'

        chromosome_string += f'{round(chromosomes["X"] / chromosome_total, 4)},'
        chromosome_string += f'{round(chromosomes["Y"] / chromosome_total, 4)},'
        chromosome_string += f'{round(chromosomes["MT"] / chromosome_total, 4)}'

        print(f'{version},{date.format("YYYY-MM-DD") if date else ""},{i_snps},{lines},{versions_string},{chromosome_string},{path.name}')

        sys.stdout.flush()

    print()

    v1 = set(version_counts['v1'].keys())
    v2 = set(version_counts['v2'].keys())
    v3 = set(version_counts['v3'].keys())
    v4 = set(version_counts['v4'].keys())
    v5 = set(version_counts['v5'].keys())

    v1_only = v1.difference(v2, v3, v4, v5)
    v2_only = v2.difference(v1, v3, v4, v5)
    v3_only = v3.difference(v1, v2, v4, v5)
    v4_only = v4.difference(v1, v2, v3, v5)
    v5_only = v5.difference(v1, v2, v3, v4)

    def do_v(name, only):
        print()
        print(name)
        print(len(only))

        counts = Counter()

        for snp in only:
            counts[snp] = version_counts[name][snp]

        sorted_terms = sorted(counts.most_common(), key=lambda x: alphanum_key(x[0]))
        sorted_terms = sorted(sorted_terms, key=lambda x: x[1], reverse=True)

        print(f'{name}_only = ['.upper())

        for term, _ in sorted_terms[0:15]:
            print(f"    '{term}',")

        print(']')

    do_v('v1', v1_only)
    do_v('v2', v2_only)
    do_v('v3', v3_only)
    do_v('v4', v4_only)
    do_v('v5', v5_only)

    # for version, counts in version_counts.items():
    #     print(f'{version}: {versions[version]}')
    #     print('---')

    #     weighted_terms = []
    #     desired_ratio = versions[version] / total

    #     for term, count in counts.items():
    #         weighted_terms.append((term, abs((count / all_counts[term]) - desired_ratio)))

    #     sorted_terms = sorted(weighted_terms, key=lambda x: alphanum_key(x[0]))
    #     sorted_terms = sorted(sorted_terms, key=lambda x: x[1])

    #     print()

    #     print('Candidates')
    #     pprint(sorted_terms[0:15])

    # for term, count in all_counts.items():
    #     if count >= total / 2:
    #         for version, counts in version_counts.items():
    #             if term in counts:
    #                 del counts[term]

    # for version, counts in version_counts.items():
    #     print('Most common after removal of top 50%')
    #     print(f'{version}: {versions[version]}')

    #     print('---')

    #     sorted_terms = sorted(counts.most_common(), key=lambda x: alphanum_key(x[0]))
    #     sorted_terms = sorted(sorted_terms, key=lambda x: x[1], reverse=True)

    #     pprint(sorted_terms[0:15])


if __name__ == '__main__':
    main()
